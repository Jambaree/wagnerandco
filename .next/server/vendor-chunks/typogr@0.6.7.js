/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/typogr@0.6.7";
exports.ids = ["vendor-chunks/typogr@0.6.7"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/typogr@0.6.7/node_modules/typogr/typogr.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/typogr@0.6.7/node_modules/typogr/typogr.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__; /*!\n  * typogr.js\n  * Copyright(c) 2011 Eugene Kalinin\n  * MIT Licensed\n  */\n\n(function (root) {\n\n  /** Main typogr function */\n  var typogr = function (obj) { return new Wrapper(obj); };\n\n  // Current version\n  typogr.version = '0.6.7';\n\n  // Export the typogr object. In server-side for `require()` API.\n  // If we're not in CommonJS, add `typogr` to the global object.\n  if ( true && module.exports) {\n    module.exports = typogr;\n   } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return typogr; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n  // typogr functions\n  // ---------------------\n\n  var re = function (regexp, flag) {\n    return new RegExp(regexp, flag);\n  };\n\n  // RegExp for skip some tags\n  var re_skip_tags = /<(\\/)?(style|pre|code|kbd|script|math|title)[^>]*>/i;\n\n  /**\n   * Wraps apersands in HTML with ``<span class=\"amp\">`` so they can be\n   * styled with CSS. Apersands are also normalized to ``&amp;``. Requires \n   * ampersands to have whitespace or an ``&nbsp;`` on both sides.\n   *\n   */\n  var amp = typogr.amp = function(text) {\n    var re_amp = /(\\s|&nbsp;)(&|&amp;|&\\#38;)(\\s|&nbsp;)/g\n                //(    $1   )(     $2       )(   $3    )\n      , re_intra_tag = /(<[^<]*>)?([^<]*)(<\\/[^<]*>)?/g;\n                      //( prefix) ( txt )(  suffix )\n    if( !text && typeof text !== \"string\" ) {\n      return;\n    }\n    return text.replace(re_intra_tag, function (str, prefix, text, suffix) {\n      prefix = prefix || '';\n      suffix = suffix || '';\n      if (prefix.match(re_skip_tags)) return prefix + text + suffix;\n      text = text.replace(re_amp, '$1<span class=\"amp\">&amp;</span>$3');\n\n      return prefix + text + suffix;\n    });\n  };\n\n  /**\n   * Wraps date suffix in <span class=\"ord\"> so they can be styled with CSS.\n   *\n   */\n  var ord = typogr.ord = function(text) {\n    if( !text && typeof text !== \"string\" ) {\n      return;\n    }\n\n    var tokens = tokenize(text)\n      , result = []\n      , in_skipped_tag = false\n      , close_match\n      , re_suffix = /(\\d+)(st|nd|rd|th)/g;\n                  //  $1        $2\n\n    tokens.forEach( function (token) {\n\n      if (token.type === 'tag') {\n        result.push(token.txt);\n\n        close_match = re_skip_tags.exec(token.txt);\n        if (close_match && close_match[1] === undefined) {\n          in_skipped_tag = true;\n        } else {\n          in_skipped_tag = false;\n        }\n      }\n      else {\n        if (in_skipped_tag) {\n          result.push(token.txt);\n        }\n        else {\n          result.push(token.txt.replace(re_suffix, '$1<span class=\"ord\">$2</span>'));\n        }\n      }\n    });\n\n    return result.join('');\n\n  };\n\n  /**\n   * Wraps initial quotes in ``class=\"dquo\"`` for double quotes or ``class=\"quo\"``\n   * for single quotes. Works in these block tags ``(h1-h6, p, li, dt, dd)``\n   * and also accounts for potential opening inline elements ``a, em, strong, span, b, i``\n   *\n   */\n  var initQuotes = typogr.initQuotes = function(text) {\n    var re_quote = re(\n            '(?:(?:<(?:p|h[1-6]|li|dt|dd)[^>]*>|^)'+  // start with an opening\n                                                      // p, h1-6, li, dd, dt\n                                                      // or the start of the string\n            '\\\\s*'+                                   // optional white space!\n            '(?:<(?:a|em|span|strong|i|b)[^>]*>\\\\s*)*)'+//optional opening inline tags,\n                                                      // with more optional white space for each.\n            '(?:(\"|&ldquo;|&#8220;)|'+                // Find me a quote! /only need to find\n             '(\\'|&lsquo;|&#8216;))'                  // the left quotes and the primes/\n          , 'i');\n\n    if( !text && typeof text !== \"string\" ) {\n      return;\n    }\n    return text.replace(re_quote, function (matched_str, dquo, squo) {\n      var classname = dquo ? \"dquo\" : \"quo\"\n        , quote = dquo ? dquo : squo;\n\n      return [matched_str.slice(0, matched_str.lastIndexOf(quote)),   // all before quote\n        '<span class=\"', classname, '\">', quote, '</span>'].join('');\n    });\n  };\n\n  /**\n   * Replaces the space between the last two words in a string with ``&nbsp;``\n   * Works in these block tags ``(h1-h6, p, li, dd, dt)`` and also accounts for\n   * potential closing inline elements ``a, em, strong, span, b, i``\n   *\n   */\n  var widont = typogr.widont = function(text) {\n    var inline_tags = 'a|em|span|strong|i|b'\n    var word = '(?:<(?:'+inline_tags+')[^>]*?>)*?[^\\\\s<>]+(?:</(?:'+inline_tags+')[^>]*?>)*?'\n    var re_widont = re(\n          '('+                                                     // matching group 1\n            '\\\\s+'+word+                                           // space and a word with a possible bordering tag\n            '\\\\s+'+word+                                           // space and a word with a possible bordering tag\n          ')'+\n          '(?:\\\\s+)'+                                              // one or more space characters\n          '('+                                                     // matching group 2\n            '[^<>\\\\s]+'+                                           // nontag/nonspace characters\n            '(?:\\\\s*</(?:a|em|span|strong|i|b)[^>]*?>\\\\s*\\\\.*)*?'+ // one or more inline closing tags\n                                                                   // can be surronded by spaces\n                                                                   // and followed by a period.\n            '(?:\\\\s*?</(?:p|h[1-6]|li|dt|dd)>|$)'+                 // allowed closing tags or end of line\n          ')', 'gi');\n    return text.replace(re_widont, '$1<span class=\"widont\">&nbsp;</span>$2');\n  };\n\n  /**\n   * Wraps multiple capital letters in ``<span class=\"caps\">``\n   * so they can be styled with CSS.\n   *\n   */\n  var caps = typogr.caps = function(text) {\n    var tokens = tokenize(text)\n      , result = []\n      , in_skipped_tag = false\n      , close_match\n      , re_cap = re(\n          '('+\n            '(\\\\b[A-Z\\\\d]*'+      // Group 2: Any amount of caps and digits\n            '[A-Z]\\\\d*[A-Z]'+     // A cap string must at least include two caps\n                                  // (but they can have digits between them)\n            '[A-Z\\\\d\\']*\\\\b)'+    // Any amount of caps and digits or dumb apostsrophes\n            '|(\\\\b[A-Z]+\\\\.\\\\s?'+  // OR: Group 3: Some caps, followed by a '.' and an optional space\n            '(?:[A-Z]+\\\\.\\\\s?)+)'+ // Followed by the same thing at least once more\n            '(?:\\\\s|\\\\b|$)'+\n          ')', 'g'\n        );\n\n      tokens.forEach( function (token) {\n\n        if (token.type === 'tag') {\n          result.push(token.txt);\n\n          close_match = re_skip_tags.exec(token.txt);\n          if (close_match && close_match[1] === undefined) {\n            in_skipped_tag = true;\n          } else {\n            in_skipped_tag = false;\n          }\n        }\n        else {\n          if (in_skipped_tag) {\n            result.push(token.txt);\n          }\n          else {\n            result.push(token.txt.replace(re_cap, function (matched_str, g1, g2, g3) {\n              // This is necessary to keep dotted cap strings to pick up extra spaces\n              var caps, tail;\n              if ( g2 ) {\n                return '<span class=\"caps\">%s</span>'.replace('%s', g2);\n              } else {\n                if ( g3.slice(-1) === ' ' ) {\n                  caps = g3.slice(0, -1);\n                  tail = ' ';\n                } else {\n                  caps = g3;\n                  tail = '';\n                }\n                return '<span class=\"caps\">%s1</span>%s2'.replace('%s1', caps).replace('%s2', tail);\n              }\n            }));\n          }\n        }\n      });\n\n      return result.join('');\n  };\n\n  /**\n   * Applies the following filters: widont, smartypants,\n   * amp, quotes\n   */\n  typogr.typogrify = function(src) {\n    var text = src;\n    if (src.jquery && src.html) {\n      text = src.html();\n    }\n\n    text = amp(text);\n    text = widont(text);\n    text = smartypants(text);\n    text = caps(text);\n    text = initQuotes(text);\n    text = ord(text);\n    return text;\n  };\n\n  // SmartyPants functions\n  // ---------------------\n\n  /**\n   * Translates plain ASCII punctuation characters into \n   * \"smart\" typographic punctuation HTML entities.\n   */\n  var smartypants = typogr.smartypants = function(text) {\n    var tokens = tokenize(text)\n      , result = []\n      , skipped_tag_stack = []\n      , skipped_tag = ''\n      , skip_match = ''\n      , in_pre = false\n        // This is a cheat, used to get some context for one-character\n        // tokens that consist of just a quote char. What we do is remember\n        // the last character of the previous text token, to use as context\n        // to curl single-character quote tokens correctly.\n      , prev_token_last_char = ''\n      , last_char\n        // current token\n      , t;\n\n    tokens.forEach( function (token) {\n      if (token.type === 'tag') {\n        // Don't mess with quotes inside some tags.\n        // This does not handle self <closing/> tags!\n        result.push(token.txt);\n\n        // is it a skipped tag ?\n        if ( (skip_match = re_skip_tags.exec(token.txt)) !== null  ) {\n          skipped_tag = skip_match[2].toLowerCase();\n\n          // closing tag\n          if ( skip_match[1] ) {\n            if ( skipped_tag_stack.length > 0 ) {\n              if ( skipped_tag === skipped_tag_stack[skipped_tag_stack.length-1] ) {\n                skipped_tag_stack.pop();\n              }\n            }\n            if (skipped_tag_stack.length === 0) {\n              in_pre = false;\n            }\n          }\n          // opening tag\n          else {\n            skipped_tag_stack.push(skipped_tag);\n            in_pre = true;\n          }\n        }\n      } else {\n        t = token.txt;\n\n        // Special case rock ’n’ roll—use apostrophes\n        t = t.replace(/(rock )'n'( roll)/gi, '$1&#8217;n&#8217;$2');\n\n        // Remember last char of this token before processing\n        last_char = t.slice(-1);\n\n        if ( !in_pre ) {\n          t = smartEscapes(t);\n          t = smartDashes(t);\n          t = smartEllipses(t);\n          // backticks need to be processed before quotes\n          t = smartBackticks(t);\n          // quotes\n          switch(t) {\n            case \"'\": // Special case: single-character ' token\n              if (/\\S/.test(prev_token_last_char)) {  t = '&#8217;'; }\n                                              else {  t = '&#8216;'; }\n              break;\n            case '\"': // Special case: single-character \" token\n              if (/\\S/.test(prev_token_last_char)) {  t = '&#8221;'; }\n                                              else {  t = '&#8220;'; }\n              break;\n            default:  // Normal case\n              t = smartQuotes(t);\n          }\n        }\n\n        prev_token_last_char = last_char;\n        result.push(t);\n      }\n    });\n\n    return result.join('');\n  };\n\n  /**\n   * Returns an array of the tokens comprising the input string.\n   * Each token is either a tag (possibly with nested, tags contained\n   * therein, such as <a href=\"<MTFoo>\">, or a run of text between tags.\n   * Each element of the array is an object with properties 'type' and 'txt';\n   * Values for 'type': 'tag' or 'text'; 'txt' is the actual value.\n   *\n   */\n  var tokenize = typogr.tokenize = function(text) {\n    var tokens = []\n      , lastIndex = 0\n      , re_tag = /([^<]*)(<[^>]*>)/gi\n      , curr_token;\n\n    while ( (curr_token = re_tag.exec(text)) !== null ) {\n      var pre_text = curr_token[1]\n        , tag_text = curr_token[2];\n\n      if (pre_text) {\n        tokens.push({ type: 'text', txt: pre_text });\n      }\n      tokens.push({ type: 'tag', txt: tag_text });\n      lastIndex = re_tag.lastIndex;\n    }\n\n    if (re_tag.lastIndex <= text.length) {\n        // if last char is a dot and not a '…'\n        // then push two tokens\n        if (text.slice(-1) == \".\" && text.slice(-2) != '..' ) {\n          tokens.push({ type: 'text', txt: text.slice(lastIndex, text.length-1) });\n          tokens.push({ type: 'text', txt: text.slice(-1) });\n        }\n        else {\n          tokens.push({ type: 'text', txt: text.slice(lastIndex) });\n        }\n    }\n\n    return tokens;\n  };\n\n  /**\n   * Returns input string, with after processing the following backslash\n   * escape sequences. This is useful if you want to force a \"dumb\"\n   * quote or other character to appear.\n   *\n   */\n  var smartEscapes = typogr.smartEscapes = function(text) {\n    return text.replace(/\\\\\"/g,   '&#34;')\n               .replace(/\\\\'/g,   '&#39;')\n               .replace(/\\\\-/g,   '&#45;')\n               .replace(/\\\\\\./g,  '&#46;')\n               .replace(/\\\\\\\\/g,  '&#92;')\n               .replace(/\\\\`/g,   '&#96;');\n  };\n\n  /**\n   * Returns input text, with each instance of \"--\"\n   * translated to an em-dash HTML entity.\n   *\n   */\n  var smartDashes = typogr.smartDashes = function(text) {\n    return text.replace(/---/g, '&#8212;')    // em  (yes, backwards)\n               .replace(/([^<][^!]|[^!]|^)--(?!>)/g,  '$1&#8211;');  // en  (yes, backwards)\n  };\n\n  /**\n   * Returns input string, with each instance of \"...\"\n   * translated to an ellipsis HTML entity.\n   *\n   */\n  var smartEllipses = typogr.smartEllipses = function(text) {\n    return text.replace(/\\.\\.\\./g,    '&#8230;')\n               .replace(/\\. \\. \\./g,  '&#8230;');\n  };\n\n  /**\n   * Returns input string, with ``backticks'' -style double quotes\n   * translated into HTML curly quote entities.\n   *\n   */\n  var smartBackticks = typogr.smartBackticks = function(text) {\n    return text.replace(/``/g,  '&#8220;')\n               .replace(/''/g,  '&#8221;');\n  };\n\n\n  /**\n   * Returns input string, with \"educated\" curly quote\n   * HTML entities.\n   *\n   */\n  var smartQuotes = typogr.smartQuotes = function(text) {\n    var punct_cls     = '[!\"#\\\\$\\\\%\\\\\\'()*+,-.\\\\/:;<=>?\\\\@\\\\[\\\\\\\\]\\\\^_`{|}~]'\n      , re_punct_str  = '(?=%s\\\\B)'.replace('%s', punct_cls)\n      , close_cls = '[^\\\\ \\\\t\\\\r\\\\n\\\\[\\\\{\\\\(\\\\-]'\n      , dec_dashes = '&#8211;|&#8212;'\n      , re_opening_single_quotes = re(\n          '('+\n                      '\\\\s|'+     // a whitespace char, or\n                   '&nbsp;|'+     // a non-breaking space entity, or\n                       '--|'+     // dashes, or\n               '&[mn]dash;|'+     // named dash entities\n            dec_dashes + '|'+     // or decimal entities\n             '&#x201[34];'+       // or hex\n          ')'+\n          '\\''+                   // the quote\n         '(?=\\\\w)', 'g')          // followed by a word character\n      , re_closing_single_quotes = re(\n          '('+close_cls+')'+\n          '\\''+                       //                      *\n          '(?!\\\\s | s\\\\b | \\\\d)' , 'g')  // ??? may be: '(?!\\s | \\s\\b | \\d)'\n      , re_closing_single_quotes2 = re(\n          '('+close_cls+')'+\n          '\\''+                   //                      *\n          '(?!\\\\s | s\\\\b)', 'g')    // ??? may be: '(?!\\s | \\s\\b)'\n      , re_opening_double_quotes = re(\n          '('+\n                      '\\\\s|'+     // a whitespace char, or\n                   '&nbsp;|'+     // a non-breaking space entity, or\n                       '--|'+     // dashes, or\n               '&[mn]dash;|'+     // named dash entities\n            dec_dashes + '|'+     // or decimal entities\n             '&#x201[34];'+       // or hex\n          ')'+\n          '\"'+                    // the quote\n          '(?=\\\\w)', 'g')         // followed by a word character\n      , re_closing_double_quotes  = re('\"(?=\\\\s)' , 'g')\n      , re_closing_double_quotes2 = re('('+close_cls+')\"', 'g');\n\n    return text\n        // Special case if the very first character is a quote\n        // followed by punctuation at a non-word-break.\n        // Close the quotes by brute force:\n        .replace(re(\"^'%s\".replace('%s', re_punct_str), 'g'), '&#8217;')\n        .replace(re('^\"%s'.replace('%s', re_punct_str), 'g'), '&#8221;')\n\n        // Special case for double sets of quotes, e.g.:\n        //  <p>He said, \"'Quoted' words in a larger quote.\"</p>\n        .replace(/\"'(?=\\w)/g, '&#8220;&#8216;')\n        .replace(/'\"(?=\\w)/g, '&#8216;&#8220;')\n\n        // Special case for decade abbreviations (the '80s):\n        .replace(/\\b'(?=\\d{2}s)/g, '&#8217;')\n\n        // Opening single quotes\n        .replace(re_opening_single_quotes, '$1&#8216;')\n        // Closing single quotes\n        .replace(re_closing_single_quotes, '$1&#8217;')\n        .replace(re_closing_single_quotes2,'$1&#8217;$2')\n        // Any remaining single quotes should be closing ones\n        .replace(\"'\", '&#8217;')\n\n        // Opening double quotes\n        .replace(re_opening_double_quotes, '$1&#8220;')\n        // Closing double quotes\n        .replace(re_closing_double_quotes, '&#8221;')\n        .replace(re_closing_double_quotes2,'$1&#8221;')\n        // Any remaining quotes should be opening ones.\n        .replace('\"', '&#8220;');\n  };\n\n  // OOP internals\n  // PS: Underscore rulez\n\n  // If typogr is called as a function, it returns a wrapped object that\n  // can be used OO-style. Wrapped objects may be chained\n  var Wrapper = function(obj) { this._wrapped = obj; };\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? typogr(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    Wrapper.prototype[name] = function() {\n      return result( func.call(typogr, this._wrapped), this._chain);\n    };\n  };\n\n  // Is a given value a function?\n  var isFunction = function(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  };\n\n  // Add all of the typogr functions to the wrapper object.\n  var name;\n  for (name in typogr) {\n    if ( typogr.hasOwnProperty(name) && isFunction(typogr[name]) ) {\n      addToWrapper(name, typogr[name]);\n    }\n  }\n\n  // Start chaining a wrapped typogr object.\n  Wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  Wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vdHlwb2dyQDAuNi43L25vZGVfbW9kdWxlcy90eXBvZ3IvdHlwb2dyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBNkI7QUFDbkM7QUFDQSxLQUFLLFNBQVMsSUFBMEM7QUFDeEQsSUFBSSxtQ0FBTyxhQUFhLGdCQUFnQjtBQUFBLGtHQUFDO0FBQ3pDLElBQUksS0FBSyxFQUVOOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsT0FBTyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMseUJBQXlCLFFBQVE7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBLDJCQUEyQixFQUFFLGNBQWM7O0FBRTNDO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRDtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxtREFBbUQ7QUFDbkQscURBQXFEO0FBQ3JEO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0B3YWduZXJhbmRjby9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS90eXBvZ3JAMC42Ljcvbm9kZV9tb2R1bGVzL3R5cG9nci90eXBvZ3IuanM/ZWE3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIgLyohXG4gICogdHlwb2dyLmpzXG4gICogQ29weXJpZ2h0KGMpIDIwMTEgRXVnZW5lIEthbGluaW5cbiAgKiBNSVQgTGljZW5zZWRcbiAgKi9cblxuKGZ1bmN0aW9uIChyb290KSB7XG5cbiAgLyoqIE1haW4gdHlwb2dyIGZ1bmN0aW9uICovXG4gIHZhciB0eXBvZ3IgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBuZXcgV3JhcHBlcihvYmopOyB9O1xuXG4gIC8vIEN1cnJlbnQgdmVyc2lvblxuICB0eXBvZ3IudmVyc2lvbiA9ICcwLjYuNyc7XG5cbiAgLy8gRXhwb3J0IHRoZSB0eXBvZ3Igb2JqZWN0LiBJbiBzZXJ2ZXItc2lkZSBmb3IgYHJlcXVpcmUoKWAgQVBJLlxuICAvLyBJZiB3ZSdyZSBub3QgaW4gQ29tbW9uSlMsIGFkZCBgdHlwb2dyYCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0eXBvZ3I7XG4gICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHR5cG9ncjsgfSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC50eXBvZ3IgPSB0eXBvZ3I7XG4gIH1cblxuICAvLyB0eXBvZ3IgZnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciByZSA9IGZ1bmN0aW9uIChyZWdleHAsIGZsYWcpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIGZsYWcpO1xuICB9O1xuXG4gIC8vIFJlZ0V4cCBmb3Igc2tpcCBzb21lIHRhZ3NcbiAgdmFyIHJlX3NraXBfdGFncyA9IC88KFxcLyk/KHN0eWxlfHByZXxjb2RlfGtiZHxzY3JpcHR8bWF0aHx0aXRsZSlbXj5dKj4vaTtcblxuICAvKipcbiAgICogV3JhcHMgYXBlcnNhbmRzIGluIEhUTUwgd2l0aCBgYDxzcGFuIGNsYXNzPVwiYW1wXCI+YGAgc28gdGhleSBjYW4gYmVcbiAgICogc3R5bGVkIHdpdGggQ1NTLiBBcGVyc2FuZHMgYXJlIGFsc28gbm9ybWFsaXplZCB0byBgYCZhbXA7YGAuIFJlcXVpcmVzIFxuICAgKiBhbXBlcnNhbmRzIHRvIGhhdmUgd2hpdGVzcGFjZSBvciBhbiBgYCZuYnNwO2BgIG9uIGJvdGggc2lkZXMuXG4gICAqXG4gICAqL1xuICB2YXIgYW1wID0gdHlwb2dyLmFtcCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgcmVfYW1wID0gLyhcXHN8Jm5ic3A7KSgmfCZhbXA7fCZcXCMzODspKFxcc3wmbmJzcDspL2dcbiAgICAgICAgICAgICAgICAvLyggICAgJDEgICApKCAgICAgJDIgICAgICAgKSggICAkMyAgICApXG4gICAgICAsIHJlX2ludHJhX3RhZyA9IC8oPFtePF0qPik/KFtePF0qKSg8XFwvW148XSo+KT8vZztcbiAgICAgICAgICAgICAgICAgICAgICAvLyggcHJlZml4KSAoIHR4dCApKCAgc3VmZml4IClcbiAgICBpZiggIXRleHQgJiYgdHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UocmVfaW50cmFfdGFnLCBmdW5jdGlvbiAoc3RyLCBwcmVmaXgsIHRleHQsIHN1ZmZpeCkge1xuICAgICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICAgICAgc3VmZml4ID0gc3VmZml4IHx8ICcnO1xuICAgICAgaWYgKHByZWZpeC5tYXRjaChyZV9za2lwX3RhZ3MpKSByZXR1cm4gcHJlZml4ICsgdGV4dCArIHN1ZmZpeDtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVfYW1wLCAnJDE8c3BhbiBjbGFzcz1cImFtcFwiPiZhbXA7PC9zcGFuPiQzJyk7XG5cbiAgICAgIHJldHVybiBwcmVmaXggKyB0ZXh0ICsgc3VmZml4O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcmFwcyBkYXRlIHN1ZmZpeCBpbiA8c3BhbiBjbGFzcz1cIm9yZFwiPiBzbyB0aGV5IGNhbiBiZSBzdHlsZWQgd2l0aCBDU1MuXG4gICAqXG4gICAqL1xuICB2YXIgb3JkID0gdHlwb2dyLm9yZCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICBpZiggIXRleHQgJiYgdHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHRva2VuaXplKHRleHQpXG4gICAgICAsIHJlc3VsdCA9IFtdXG4gICAgICAsIGluX3NraXBwZWRfdGFnID0gZmFsc2VcbiAgICAgICwgY2xvc2VfbWF0Y2hcbiAgICAgICwgcmVfc3VmZml4ID0gLyhcXGQrKShzdHxuZHxyZHx0aCkvZztcbiAgICAgICAgICAgICAgICAgIC8vICAkMSAgICAgICAgJDJcblxuICAgIHRva2Vucy5mb3JFYWNoKCBmdW5jdGlvbiAodG9rZW4pIHtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuLnR4dCk7XG5cbiAgICAgICAgY2xvc2VfbWF0Y2ggPSByZV9za2lwX3RhZ3MuZXhlYyh0b2tlbi50eHQpO1xuICAgICAgICBpZiAoY2xvc2VfbWF0Y2ggJiYgY2xvc2VfbWF0Y2hbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluX3NraXBwZWRfdGFnID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbl9za2lwcGVkX3RhZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGluX3NraXBwZWRfdGFnKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4udHh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh0b2tlbi50eHQucmVwbGFjZShyZV9zdWZmaXgsICckMTxzcGFuIGNsYXNzPVwib3JkXCI+JDI8L3NwYW4+JykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIFdyYXBzIGluaXRpYWwgcXVvdGVzIGluIGBgY2xhc3M9XCJkcXVvXCJgYCBmb3IgZG91YmxlIHF1b3RlcyBvciBgYGNsYXNzPVwicXVvXCJgYFxuICAgKiBmb3Igc2luZ2xlIHF1b3Rlcy4gV29ya3MgaW4gdGhlc2UgYmxvY2sgdGFncyBgYChoMS1oNiwgcCwgbGksIGR0LCBkZClgYFxuICAgKiBhbmQgYWxzbyBhY2NvdW50cyBmb3IgcG90ZW50aWFsIG9wZW5pbmcgaW5saW5lIGVsZW1lbnRzIGBgYSwgZW0sIHN0cm9uZywgc3BhbiwgYiwgaWBgXG4gICAqXG4gICAqL1xuICB2YXIgaW5pdFF1b3RlcyA9IHR5cG9nci5pbml0UXVvdGVzID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciByZV9xdW90ZSA9IHJlKFxuICAgICAgICAgICAgJyg/Oig/OjwoPzpwfGhbMS02XXxsaXxkdHxkZClbXj5dKj58XiknKyAgLy8gc3RhcnQgd2l0aCBhbiBvcGVuaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwLCBoMS02LCBsaSwgZGQsIGR0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgJ1xcXFxzKicrICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCB3aGl0ZSBzcGFjZSFcbiAgICAgICAgICAgICcoPzo8KD86YXxlbXxzcGFufHN0cm9uZ3xpfGIpW14+XSo+XFxcXHMqKSopJysvL29wdGlvbmFsIG9wZW5pbmcgaW5saW5lIHRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIG1vcmUgb3B0aW9uYWwgd2hpdGUgc3BhY2UgZm9yIGVhY2guXG4gICAgICAgICAgICAnKD86KFwifCZsZHF1bzt8JiM4MjIwOyl8JysgICAgICAgICAgICAgICAgLy8gRmluZCBtZSBhIHF1b3RlISAvb25seSBuZWVkIHRvIGZpbmRcbiAgICAgICAgICAgICAnKFxcJ3wmbHNxdW87fCYjODIxNjspKScgICAgICAgICAgICAgICAgICAvLyB0aGUgbGVmdCBxdW90ZXMgYW5kIHRoZSBwcmltZXMvXG4gICAgICAgICAgLCAnaScpO1xuXG4gICAgaWYoICF0ZXh0ICYmIHR5cGVvZiB0ZXh0ICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlX3F1b3RlLCBmdW5jdGlvbiAobWF0Y2hlZF9zdHIsIGRxdW8sIHNxdW8pIHtcbiAgICAgIHZhciBjbGFzc25hbWUgPSBkcXVvID8gXCJkcXVvXCIgOiBcInF1b1wiXG4gICAgICAgICwgcXVvdGUgPSBkcXVvID8gZHF1byA6IHNxdW87XG5cbiAgICAgIHJldHVybiBbbWF0Y2hlZF9zdHIuc2xpY2UoMCwgbWF0Y2hlZF9zdHIubGFzdEluZGV4T2YocXVvdGUpKSwgICAvLyBhbGwgYmVmb3JlIHF1b3RlXG4gICAgICAgICc8c3BhbiBjbGFzcz1cIicsIGNsYXNzbmFtZSwgJ1wiPicsIHF1b3RlLCAnPC9zcGFuPiddLmpvaW4oJycpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgbGFzdCB0d28gd29yZHMgaW4gYSBzdHJpbmcgd2l0aCBgYCZuYnNwO2BgXG4gICAqIFdvcmtzIGluIHRoZXNlIGJsb2NrIHRhZ3MgYGAoaDEtaDYsIHAsIGxpLCBkZCwgZHQpYGAgYW5kIGFsc28gYWNjb3VudHMgZm9yXG4gICAqIHBvdGVudGlhbCBjbG9zaW5nIGlubGluZSBlbGVtZW50cyBgYGEsIGVtLCBzdHJvbmcsIHNwYW4sIGIsIGlgYFxuICAgKlxuICAgKi9cbiAgdmFyIHdpZG9udCA9IHR5cG9nci53aWRvbnQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIGlubGluZV90YWdzID0gJ2F8ZW18c3BhbnxzdHJvbmd8aXxiJ1xuICAgIHZhciB3b3JkID0gJyg/OjwoPzonK2lubGluZV90YWdzKycpW14+XSo/PikqP1teXFxcXHM8Pl0rKD86PC8oPzonK2lubGluZV90YWdzKycpW14+XSo/PikqPydcbiAgICB2YXIgcmVfd2lkb250ID0gcmUoXG4gICAgICAgICAgJygnKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hpbmcgZ3JvdXAgMVxuICAgICAgICAgICAgJ1xcXFxzKycrd29yZCsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UgYW5kIGEgd29yZCB3aXRoIGEgcG9zc2libGUgYm9yZGVyaW5nIHRhZ1xuICAgICAgICAgICAgJ1xcXFxzKycrd29yZCsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UgYW5kIGEgd29yZCB3aXRoIGEgcG9zc2libGUgYm9yZGVyaW5nIHRhZ1xuICAgICAgICAgICcpJytcbiAgICAgICAgICAnKD86XFxcXHMrKScrICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uZSBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgICAnKCcrICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaGluZyBncm91cCAyXG4gICAgICAgICAgICAnW148PlxcXFxzXSsnKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub250YWcvbm9uc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgICAgICAgJyg/OlxcXFxzKjwvKD86YXxlbXxzcGFufHN0cm9uZ3xpfGIpW14+XSo/PlxcXFxzKlxcXFwuKikqPycrIC8vIG9uZSBvciBtb3JlIGlubGluZSBjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gYmUgc3Vycm9uZGVkIGJ5IHNwYWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBmb2xsb3dlZCBieSBhIHBlcmlvZC5cbiAgICAgICAgICAgICcoPzpcXFxccyo/PC8oPzpwfGhbMS02XXxsaXxkdHxkZCk+fCQpJysgICAgICAgICAgICAgICAgIC8vIGFsbG93ZWQgY2xvc2luZyB0YWdzIG9yIGVuZCBvZiBsaW5lXG4gICAgICAgICAgJyknLCAnZ2knKTtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlX3dpZG9udCwgJyQxPHNwYW4gY2xhc3M9XCJ3aWRvbnRcIj4mbmJzcDs8L3NwYW4+JDInKTtcbiAgfTtcblxuICAvKipcbiAgICogV3JhcHMgbXVsdGlwbGUgY2FwaXRhbCBsZXR0ZXJzIGluIGBgPHNwYW4gY2xhc3M9XCJjYXBzXCI+YGBcbiAgICogc28gdGhleSBjYW4gYmUgc3R5bGVkIHdpdGggQ1NTLlxuICAgKlxuICAgKi9cbiAgdmFyIGNhcHMgPSB0eXBvZ3IuY2FwcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgdG9rZW5zID0gdG9rZW5pemUodGV4dClcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwgaW5fc2tpcHBlZF90YWcgPSBmYWxzZVxuICAgICAgLCBjbG9zZV9tYXRjaFxuICAgICAgLCByZV9jYXAgPSByZShcbiAgICAgICAgICAnKCcrXG4gICAgICAgICAgICAnKFxcXFxiW0EtWlxcXFxkXSonKyAgICAgIC8vIEdyb3VwIDI6IEFueSBhbW91bnQgb2YgY2FwcyBhbmQgZGlnaXRzXG4gICAgICAgICAgICAnW0EtWl1cXFxcZCpbQS1aXScrICAgICAvLyBBIGNhcCBzdHJpbmcgbXVzdCBhdCBsZWFzdCBpbmNsdWRlIHR3byBjYXBzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGJ1dCB0aGV5IGNhbiBoYXZlIGRpZ2l0cyBiZXR3ZWVuIHRoZW0pXG4gICAgICAgICAgICAnW0EtWlxcXFxkXFwnXSpcXFxcYiknKyAgICAvLyBBbnkgYW1vdW50IG9mIGNhcHMgYW5kIGRpZ2l0cyBvciBkdW1iIGFwb3N0c3JvcGhlc1xuICAgICAgICAgICAgJ3woXFxcXGJbQS1aXStcXFxcLlxcXFxzPycrICAvLyBPUjogR3JvdXAgMzogU29tZSBjYXBzLCBmb2xsb3dlZCBieSBhICcuJyBhbmQgYW4gb3B0aW9uYWwgc3BhY2VcbiAgICAgICAgICAgICcoPzpbQS1aXStcXFxcLlxcXFxzPykrKScrIC8vIEZvbGxvd2VkIGJ5IHRoZSBzYW1lIHRoaW5nIGF0IGxlYXN0IG9uY2UgbW9yZVxuICAgICAgICAgICAgJyg/OlxcXFxzfFxcXFxifCQpJytcbiAgICAgICAgICAnKScsICdnJ1xuICAgICAgICApO1xuXG4gICAgICB0b2tlbnMuZm9yRWFjaCggZnVuY3Rpb24gKHRva2VuKSB7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4udHh0KTtcblxuICAgICAgICAgIGNsb3NlX21hdGNoID0gcmVfc2tpcF90YWdzLmV4ZWModG9rZW4udHh0KTtcbiAgICAgICAgICBpZiAoY2xvc2VfbWF0Y2ggJiYgY2xvc2VfbWF0Y2hbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5fc2tpcHBlZF90YWcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbl9za2lwcGVkX3RhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaW5fc2tpcHBlZF90YWcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRva2VuLnR4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4udHh0LnJlcGxhY2UocmVfY2FwLCBmdW5jdGlvbiAobWF0Y2hlZF9zdHIsIGcxLCBnMiwgZzMpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8ga2VlcCBkb3R0ZWQgY2FwIHN0cmluZ3MgdG8gcGljayB1cCBleHRyYSBzcGFjZXNcbiAgICAgICAgICAgICAgdmFyIGNhcHMsIHRhaWw7XG4gICAgICAgICAgICAgIGlmICggZzIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cImNhcHNcIj4lczwvc3Bhbj4nLnJlcGxhY2UoJyVzJywgZzIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICggZzMuc2xpY2UoLTEpID09PSAnICcgKSB7XG4gICAgICAgICAgICAgICAgICBjYXBzID0gZzMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgICAgdGFpbCA9ICcgJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY2FwcyA9IGczO1xuICAgICAgICAgICAgICAgICAgdGFpbCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiY2Fwc1wiPiVzMTwvc3Bhbj4lczInLnJlcGxhY2UoJyVzMScsIGNhcHMpLnJlcGxhY2UoJyVzMicsIHRhaWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZm9sbG93aW5nIGZpbHRlcnM6IHdpZG9udCwgc21hcnR5cGFudHMsXG4gICAqIGFtcCwgcXVvdGVzXG4gICAqL1xuICB0eXBvZ3IudHlwb2dyaWZ5ID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgdmFyIHRleHQgPSBzcmM7XG4gICAgaWYgKHNyYy5qcXVlcnkgJiYgc3JjLmh0bWwpIHtcbiAgICAgIHRleHQgPSBzcmMuaHRtbCgpO1xuICAgIH1cblxuICAgIHRleHQgPSBhbXAodGV4dCk7XG4gICAgdGV4dCA9IHdpZG9udCh0ZXh0KTtcbiAgICB0ZXh0ID0gc21hcnR5cGFudHModGV4dCk7XG4gICAgdGV4dCA9IGNhcHModGV4dCk7XG4gICAgdGV4dCA9IGluaXRRdW90ZXModGV4dCk7XG4gICAgdGV4dCA9IG9yZCh0ZXh0KTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICAvLyBTbWFydHlQYW50cyBmdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgcGxhaW4gQVNDSUkgcHVuY3R1YXRpb24gY2hhcmFjdGVycyBpbnRvIFxuICAgKiBcInNtYXJ0XCIgdHlwb2dyYXBoaWMgcHVuY3R1YXRpb24gSFRNTCBlbnRpdGllcy5cbiAgICovXG4gIHZhciBzbWFydHlwYW50cyA9IHR5cG9nci5zbWFydHlwYW50cyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgdG9rZW5zID0gdG9rZW5pemUodGV4dClcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwgc2tpcHBlZF90YWdfc3RhY2sgPSBbXVxuICAgICAgLCBza2lwcGVkX3RhZyA9ICcnXG4gICAgICAsIHNraXBfbWF0Y2ggPSAnJ1xuICAgICAgLCBpbl9wcmUgPSBmYWxzZVxuICAgICAgICAvLyBUaGlzIGlzIGEgY2hlYXQsIHVzZWQgdG8gZ2V0IHNvbWUgY29udGV4dCBmb3Igb25lLWNoYXJhY3RlclxuICAgICAgICAvLyB0b2tlbnMgdGhhdCBjb25zaXN0IG9mIGp1c3QgYSBxdW90ZSBjaGFyLiBXaGF0IHdlIGRvIGlzIHJlbWVtYmVyXG4gICAgICAgIC8vIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgcHJldmlvdXMgdGV4dCB0b2tlbiwgdG8gdXNlIGFzIGNvbnRleHRcbiAgICAgICAgLy8gdG8gY3VybCBzaW5nbGUtY2hhcmFjdGVyIHF1b3RlIHRva2VucyBjb3JyZWN0bHkuXG4gICAgICAsIHByZXZfdG9rZW5fbGFzdF9jaGFyID0gJydcbiAgICAgICwgbGFzdF9jaGFyXG4gICAgICAgIC8vIGN1cnJlbnQgdG9rZW5cbiAgICAgICwgdDtcblxuICAgIHRva2Vucy5mb3JFYWNoKCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAndGFnJykge1xuICAgICAgICAvLyBEb24ndCBtZXNzIHdpdGggcXVvdGVzIGluc2lkZSBzb21lIHRhZ3MuXG4gICAgICAgIC8vIFRoaXMgZG9lcyBub3QgaGFuZGxlIHNlbGYgPGNsb3NpbmcvPiB0YWdzIVxuICAgICAgICByZXN1bHQucHVzaCh0b2tlbi50eHQpO1xuXG4gICAgICAgIC8vIGlzIGl0IGEgc2tpcHBlZCB0YWcgP1xuICAgICAgICBpZiAoIChza2lwX21hdGNoID0gcmVfc2tpcF90YWdzLmV4ZWModG9rZW4udHh0KSkgIT09IG51bGwgICkge1xuICAgICAgICAgIHNraXBwZWRfdGFnID0gc2tpcF9tYXRjaFsyXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgLy8gY2xvc2luZyB0YWdcbiAgICAgICAgICBpZiAoIHNraXBfbWF0Y2hbMV0gKSB7XG4gICAgICAgICAgICBpZiAoIHNraXBwZWRfdGFnX3N0YWNrLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgIGlmICggc2tpcHBlZF90YWcgPT09IHNraXBwZWRfdGFnX3N0YWNrW3NraXBwZWRfdGFnX3N0YWNrLmxlbmd0aC0xXSApIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkX3RhZ19zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNraXBwZWRfdGFnX3N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBpbl9wcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3BlbmluZyB0YWdcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNraXBwZWRfdGFnX3N0YWNrLnB1c2goc2tpcHBlZF90YWcpO1xuICAgICAgICAgICAgaW5fcHJlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSB0b2tlbi50eHQ7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHJvY2sg4oCZbuKAmSByb2xs4oCUdXNlIGFwb3N0cm9waGVzXG4gICAgICAgIHQgPSB0LnJlcGxhY2UoLyhyb2NrICknbicoIHJvbGwpL2dpLCAnJDEmIzgyMTc7biYjODIxNzskMicpO1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIGxhc3QgY2hhciBvZiB0aGlzIHRva2VuIGJlZm9yZSBwcm9jZXNzaW5nXG4gICAgICAgIGxhc3RfY2hhciA9IHQuc2xpY2UoLTEpO1xuXG4gICAgICAgIGlmICggIWluX3ByZSApIHtcbiAgICAgICAgICB0ID0gc21hcnRFc2NhcGVzKHQpO1xuICAgICAgICAgIHQgPSBzbWFydERhc2hlcyh0KTtcbiAgICAgICAgICB0ID0gc21hcnRFbGxpcHNlcyh0KTtcbiAgICAgICAgICAvLyBiYWNrdGlja3MgbmVlZCB0byBiZSBwcm9jZXNzZWQgYmVmb3JlIHF1b3Rlc1xuICAgICAgICAgIHQgPSBzbWFydEJhY2t0aWNrcyh0KTtcbiAgICAgICAgICAvLyBxdW90ZXNcbiAgICAgICAgICBzd2l0Y2godCkge1xuICAgICAgICAgICAgY2FzZSBcIidcIjogLy8gU3BlY2lhbCBjYXNlOiBzaW5nbGUtY2hhcmFjdGVyICcgdG9rZW5cbiAgICAgICAgICAgICAgaWYgKC9cXFMvLnRlc3QocHJldl90b2tlbl9sYXN0X2NoYXIpKSB7ICB0ID0gJyYjODIxNzsnOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICB0ID0gJyYjODIxNjsnOyB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnXCInOiAvLyBTcGVjaWFsIGNhc2U6IHNpbmdsZS1jaGFyYWN0ZXIgXCIgdG9rZW5cbiAgICAgICAgICAgICAgaWYgKC9cXFMvLnRlc3QocHJldl90b2tlbl9sYXN0X2NoYXIpKSB7ICB0ID0gJyYjODIyMTsnOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICB0ID0gJyYjODIyMDsnOyB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogIC8vIE5vcm1hbCBjYXNlXG4gICAgICAgICAgICAgIHQgPSBzbWFydFF1b3Rlcyh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2X3Rva2VuX2xhc3RfY2hhciA9IGxhc3RfY2hhcjtcbiAgICAgICAgcmVzdWx0LnB1c2godCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgaW5wdXQgc3RyaW5nLlxuICAgKiBFYWNoIHRva2VuIGlzIGVpdGhlciBhIHRhZyAocG9zc2libHkgd2l0aCBuZXN0ZWQsIHRhZ3MgY29udGFpbmVkXG4gICAqIHRoZXJlaW4sIHN1Y2ggYXMgPGEgaHJlZj1cIjxNVEZvbz5cIj4sIG9yIGEgcnVuIG9mIHRleHQgYmV0d2VlbiB0YWdzLlxuICAgKiBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgJ3R5cGUnIGFuZCAndHh0JztcbiAgICogVmFsdWVzIGZvciAndHlwZSc6ICd0YWcnIG9yICd0ZXh0JzsgJ3R4dCcgaXMgdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICpcbiAgICovXG4gIHZhciB0b2tlbml6ZSA9IHR5cG9nci50b2tlbml6ZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgdG9rZW5zID0gW11cbiAgICAgICwgbGFzdEluZGV4ID0gMFxuICAgICAgLCByZV90YWcgPSAvKFtePF0qKSg8W14+XSo+KS9naVxuICAgICAgLCBjdXJyX3Rva2VuO1xuXG4gICAgd2hpbGUgKCAoY3Vycl90b2tlbiA9IHJlX3RhZy5leGVjKHRleHQpKSAhPT0gbnVsbCApIHtcbiAgICAgIHZhciBwcmVfdGV4dCA9IGN1cnJfdG9rZW5bMV1cbiAgICAgICAgLCB0YWdfdGV4dCA9IGN1cnJfdG9rZW5bMl07XG5cbiAgICAgIGlmIChwcmVfdGV4dCkge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICd0ZXh0JywgdHh0OiBwcmVfdGV4dCB9KTtcbiAgICAgIH1cbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ3RhZycsIHR4dDogdGFnX3RleHQgfSk7XG4gICAgICBsYXN0SW5kZXggPSByZV90YWcubGFzdEluZGV4O1xuICAgIH1cblxuICAgIGlmIChyZV90YWcubGFzdEluZGV4IDw9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vIGlmIGxhc3QgY2hhciBpcyBhIGRvdCBhbmQgbm90IGEgJ+KApidcbiAgICAgICAgLy8gdGhlbiBwdXNoIHR3byB0b2tlbnNcbiAgICAgICAgaWYgKHRleHQuc2xpY2UoLTEpID09IFwiLlwiICYmIHRleHQuc2xpY2UoLTIpICE9ICcuLicgKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAndGV4dCcsIHR4dDogdGV4dC5zbGljZShsYXN0SW5kZXgsIHRleHQubGVuZ3RoLTEpIH0pO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ3RleHQnLCB0eHQ6IHRleHQuc2xpY2UoLTEpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ3RleHQnLCB0eHQ6IHRleHQuc2xpY2UobGFzdEluZGV4KSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5wdXQgc3RyaW5nLCB3aXRoIGFmdGVyIHByb2Nlc3NpbmcgdGhlIGZvbGxvd2luZyBiYWNrc2xhc2hcbiAgICogZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZm9yY2UgYSBcImR1bWJcIlxuICAgKiBxdW90ZSBvciBvdGhlciBjaGFyYWN0ZXIgdG8gYXBwZWFyLlxuICAgKlxuICAgKi9cbiAgdmFyIHNtYXJ0RXNjYXBlcyA9IHR5cG9nci5zbWFydEVzY2FwZXMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFxcXFwiL2csICAgJyYjMzQ7JylcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcJy9nLCAgICcmIzM5OycpXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXC0vZywgICAnJiM0NTsnKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcXC4vZywgICcmIzQ2OycpXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgICcmIzkyOycpXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXGAvZywgICAnJiM5NjsnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBpbnB1dCB0ZXh0LCB3aXRoIGVhY2ggaW5zdGFuY2Ugb2YgXCItLVwiXG4gICAqIHRyYW5zbGF0ZWQgdG8gYW4gZW0tZGFzaCBIVE1MIGVudGl0eS5cbiAgICpcbiAgICovXG4gIHZhciBzbWFydERhc2hlcyA9IHR5cG9nci5zbWFydERhc2hlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8tLS0vZywgJyYjODIxMjsnKSAgICAvLyBlbSAgKHllcywgYmFja3dhcmRzKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbXjxdW14hXXxbXiFdfF4pLS0oPyE+KS9nLCAgJyQxJiM4MjExOycpOyAgLy8gZW4gICh5ZXMsIGJhY2t3YXJkcylcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBpbnB1dCBzdHJpbmcsIHdpdGggZWFjaCBpbnN0YW5jZSBvZiBcIi4uLlwiXG4gICAqIHRyYW5zbGF0ZWQgdG8gYW4gZWxsaXBzaXMgSFRNTCBlbnRpdHkuXG4gICAqXG4gICAqL1xuICB2YXIgc21hcnRFbGxpcHNlcyA9IHR5cG9nci5zbWFydEVsbGlwc2VzID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcLlxcLlxcLi9nLCAgICAnJiM4MjMwOycpXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuIFxcLiBcXC4vZywgICcmIzgyMzA7Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5wdXQgc3RyaW5nLCB3aXRoIGBgYmFja3RpY2tzJycgLXN0eWxlIGRvdWJsZSBxdW90ZXNcbiAgICogdHJhbnNsYXRlZCBpbnRvIEhUTUwgY3VybHkgcXVvdGUgZW50aXRpZXMuXG4gICAqXG4gICAqL1xuICB2YXIgc21hcnRCYWNrdGlja3MgPSB0eXBvZ3Iuc21hcnRCYWNrdGlja3MgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvYGAvZywgICcmIzgyMjA7JylcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nJy9nLCAgJyYjODIyMTsnKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlucHV0IHN0cmluZywgd2l0aCBcImVkdWNhdGVkXCIgY3VybHkgcXVvdGVcbiAgICogSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICovXG4gIHZhciBzbWFydFF1b3RlcyA9IHR5cG9nci5zbWFydFF1b3RlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgcHVuY3RfY2xzICAgICA9ICdbIVwiI1xcXFwkXFxcXCVcXFxcXFwnKCkqKywtLlxcXFwvOjs8PT4/XFxcXEBcXFxcW1xcXFxcXFxcXVxcXFxeX2B7fH1+XSdcbiAgICAgICwgcmVfcHVuY3Rfc3RyICA9ICcoPz0lc1xcXFxCKScucmVwbGFjZSgnJXMnLCBwdW5jdF9jbHMpXG4gICAgICAsIGNsb3NlX2NscyA9ICdbXlxcXFwgXFxcXHRcXFxcclxcXFxuXFxcXFtcXFxce1xcXFwoXFxcXC1dJ1xuICAgICAgLCBkZWNfZGFzaGVzID0gJyYjODIxMTt8JiM4MjEyOydcbiAgICAgICwgcmVfb3BlbmluZ19zaW5nbGVfcXVvdGVzID0gcmUoXG4gICAgICAgICAgJygnK1xuICAgICAgICAgICAgICAgICAgICAgICdcXFxcc3wnKyAgICAgLy8gYSB3aGl0ZXNwYWNlIGNoYXIsIG9yXG4gICAgICAgICAgICAgICAgICAgJyZuYnNwO3wnKyAgICAgLy8gYSBub24tYnJlYWtpbmcgc3BhY2UgZW50aXR5LCBvclxuICAgICAgICAgICAgICAgICAgICAgICAnLS18JysgICAgIC8vIGRhc2hlcywgb3JcbiAgICAgICAgICAgICAgICcmW21uXWRhc2g7fCcrICAgICAvLyBuYW1lZCBkYXNoIGVudGl0aWVzXG4gICAgICAgICAgICBkZWNfZGFzaGVzICsgJ3wnKyAgICAgLy8gb3IgZGVjaW1hbCBlbnRpdGllc1xuICAgICAgICAgICAgICcmI3gyMDFbMzRdOycrICAgICAgIC8vIG9yIGhleFxuICAgICAgICAgICcpJytcbiAgICAgICAgICAnXFwnJysgICAgICAgICAgICAgICAgICAgLy8gdGhlIHF1b3RlXG4gICAgICAgICAnKD89XFxcXHcpJywgJ2cnKSAgICAgICAgICAvLyBmb2xsb3dlZCBieSBhIHdvcmQgY2hhcmFjdGVyXG4gICAgICAsIHJlX2Nsb3Npbmdfc2luZ2xlX3F1b3RlcyA9IHJlKFxuICAgICAgICAgICcoJytjbG9zZV9jbHMrJyknK1xuICAgICAgICAgICdcXCcnKyAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICcoPyFcXFxccyB8IHNcXFxcYiB8IFxcXFxkKScgLCAnZycpICAvLyA/Pz8gbWF5IGJlOiAnKD8hXFxzIHwgXFxzXFxiIHwgXFxkKSdcbiAgICAgICwgcmVfY2xvc2luZ19zaW5nbGVfcXVvdGVzMiA9IHJlKFxuICAgICAgICAgICcoJytjbG9zZV9jbHMrJyknK1xuICAgICAgICAgICdcXCcnKyAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgJyg/IVxcXFxzIHwgc1xcXFxiKScsICdnJykgICAgLy8gPz8/IG1heSBiZTogJyg/IVxccyB8IFxcc1xcYiknXG4gICAgICAsIHJlX29wZW5pbmdfZG91YmxlX3F1b3RlcyA9IHJlKFxuICAgICAgICAgICcoJytcbiAgICAgICAgICAgICAgICAgICAgICAnXFxcXHN8JysgICAgIC8vIGEgd2hpdGVzcGFjZSBjaGFyLCBvclxuICAgICAgICAgICAgICAgICAgICcmbmJzcDt8JysgICAgIC8vIGEgbm9uLWJyZWFraW5nIHNwYWNlIGVudGl0eSwgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgJy0tfCcrICAgICAvLyBkYXNoZXMsIG9yXG4gICAgICAgICAgICAgICAnJlttbl1kYXNoO3wnKyAgICAgLy8gbmFtZWQgZGFzaCBlbnRpdGllc1xuICAgICAgICAgICAgZGVjX2Rhc2hlcyArICd8JysgICAgIC8vIG9yIGRlY2ltYWwgZW50aXRpZXNcbiAgICAgICAgICAgICAnJiN4MjAxWzM0XTsnKyAgICAgICAvLyBvciBoZXhcbiAgICAgICAgICAnKScrXG4gICAgICAgICAgJ1wiJysgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBxdW90ZVxuICAgICAgICAgICcoPz1cXFxcdyknLCAnZycpICAgICAgICAgLy8gZm9sbG93ZWQgYnkgYSB3b3JkIGNoYXJhY3RlclxuICAgICAgLCByZV9jbG9zaW5nX2RvdWJsZV9xdW90ZXMgID0gcmUoJ1wiKD89XFxcXHMpJyAsICdnJylcbiAgICAgICwgcmVfY2xvc2luZ19kb3VibGVfcXVvdGVzMiA9IHJlKCcoJytjbG9zZV9jbHMrJylcIicsICdnJyk7XG5cbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgaWYgdGhlIHZlcnkgZmlyc3QgY2hhcmFjdGVyIGlzIGEgcXVvdGVcbiAgICAgICAgLy8gZm9sbG93ZWQgYnkgcHVuY3R1YXRpb24gYXQgYSBub24td29yZC1icmVhay5cbiAgICAgICAgLy8gQ2xvc2UgdGhlIHF1b3RlcyBieSBicnV0ZSBmb3JjZTpcbiAgICAgICAgLnJlcGxhY2UocmUoXCJeJyVzXCIucmVwbGFjZSgnJXMnLCByZV9wdW5jdF9zdHIpLCAnZycpLCAnJiM4MjE3OycpXG4gICAgICAgIC5yZXBsYWNlKHJlKCdeXCIlcycucmVwbGFjZSgnJXMnLCByZV9wdW5jdF9zdHIpLCAnZycpLCAnJiM4MjIxOycpXG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBkb3VibGUgc2V0cyBvZiBxdW90ZXMsIGUuZy46XG4gICAgICAgIC8vICA8cD5IZSBzYWlkLCBcIidRdW90ZWQnIHdvcmRzIGluIGEgbGFyZ2VyIHF1b3RlLlwiPC9wPlxuICAgICAgICAucmVwbGFjZSgvXCInKD89XFx3KS9nLCAnJiM4MjIwOyYjODIxNjsnKVxuICAgICAgICAucmVwbGFjZSgvJ1wiKD89XFx3KS9nLCAnJiM4MjE2OyYjODIyMDsnKVxuXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZGVjYWRlIGFiYnJldmlhdGlvbnMgKHRoZSAnODBzKTpcbiAgICAgICAgLnJlcGxhY2UoL1xcYicoPz1cXGR7Mn1zKS9nLCAnJiM4MjE3OycpXG5cbiAgICAgICAgLy8gT3BlbmluZyBzaW5nbGUgcXVvdGVzXG4gICAgICAgIC5yZXBsYWNlKHJlX29wZW5pbmdfc2luZ2xlX3F1b3RlcywgJyQxJiM4MjE2OycpXG4gICAgICAgIC8vIENsb3Npbmcgc2luZ2xlIHF1b3Rlc1xuICAgICAgICAucmVwbGFjZShyZV9jbG9zaW5nX3NpbmdsZV9xdW90ZXMsICckMSYjODIxNzsnKVxuICAgICAgICAucmVwbGFjZShyZV9jbG9zaW5nX3NpbmdsZV9xdW90ZXMyLCckMSYjODIxNzskMicpXG4gICAgICAgIC8vIEFueSByZW1haW5pbmcgc2luZ2xlIHF1b3RlcyBzaG91bGQgYmUgY2xvc2luZyBvbmVzXG4gICAgICAgIC5yZXBsYWNlKFwiJ1wiLCAnJiM4MjE3OycpXG5cbiAgICAgICAgLy8gT3BlbmluZyBkb3VibGUgcXVvdGVzXG4gICAgICAgIC5yZXBsYWNlKHJlX29wZW5pbmdfZG91YmxlX3F1b3RlcywgJyQxJiM4MjIwOycpXG4gICAgICAgIC8vIENsb3NpbmcgZG91YmxlIHF1b3Rlc1xuICAgICAgICAucmVwbGFjZShyZV9jbG9zaW5nX2RvdWJsZV9xdW90ZXMsICcmIzgyMjE7JylcbiAgICAgICAgLnJlcGxhY2UocmVfY2xvc2luZ19kb3VibGVfcXVvdGVzMiwnJDEmIzgyMjE7JylcbiAgICAgICAgLy8gQW55IHJlbWFpbmluZyBxdW90ZXMgc2hvdWxkIGJlIG9wZW5pbmcgb25lcy5cbiAgICAgICAgLnJlcGxhY2UoJ1wiJywgJyYjODIyMDsnKTtcbiAgfTtcblxuICAvLyBPT1AgaW50ZXJuYWxzXG4gIC8vIFBTOiBVbmRlcnNjb3JlIHJ1bGV6XG5cbiAgLy8gSWYgdHlwb2dyIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkXG4gIHZhciBXcmFwcGVyID0gZnVuY3Rpb24ob2JqKSB7IHRoaXMuX3dyYXBwZWQgPSBvYmo7IH07XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24ob2JqLCBjaGFpbikge1xuICAgIHJldHVybiBjaGFpbiA/IHR5cG9ncihvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQSBtZXRob2QgdG8gZWFzaWx5IGFkZCBmdW5jdGlvbnMgdG8gdGhlIE9PUCB3cmFwcGVyLlxuICB2YXIgYWRkVG9XcmFwcGVyID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgIFdyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KCBmdW5jLmNhbGwodHlwb2dyLCB0aGlzLl93cmFwcGVkKSwgdGhpcy5fY2hhaW4pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGZ1bmN0aW9uP1xuICB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jYWxsICYmIG9iai5hcHBseSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgdHlwb2dyIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIHZhciBuYW1lO1xuICBmb3IgKG5hbWUgaW4gdHlwb2dyKSB7XG4gICAgaWYgKCB0eXBvZ3IuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNGdW5jdGlvbih0eXBvZ3JbbmFtZV0pICkge1xuICAgICAgYWRkVG9XcmFwcGVyKG5hbWUsIHR5cG9ncltuYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIHR5cG9nciBvYmplY3QuXG4gIFdyYXBwZXIucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG59KHRoaXMpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/typogr@0.6.7/node_modules/typogr/typogr.js\n");

/***/ })

};
;